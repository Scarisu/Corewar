init.c:		colors[champs[i].reg->pc] += 5;
opcodes/op_add.c:	if (++reg->cycle == 10)
opcodes/op_add.c:		(pc = reg->pc + 2) >= MEM_SIZE ? pc -= MEM_SIZE : pc;
opcodes/op_add.c:		reg->r[r[2]] = reg->r[r[0]] + reg->r[r[1]];
opcodes/op_add.c:		reg->carry = !reg->r[r[2]] ? 1 : 0;
opcodes/op_add.c:		reg->cycle = 0;
opcodes/op_add.c:		//printw("r%d = %d\n", r[0], reg->r[r[0]]);
opcodes/op_add.c:		//printw("r%d = %d\n", r[1], reg->r[r[1]]);
opcodes/op_add.c:		//printw("r%d = %d\n", r[2], reg->r[r[2]]);
opcodes/op_and.c:	reg->r[r[2]] = r[0] & r[1];
opcodes/op_and.c:	reg->carry = !reg->r[r[2]] ? 1 : 0;
opcodes/op_and.c:	if (++reg->cycle == 7)
opcodes/op_and.c:		(pc = reg->pc + 1) >= MEM_SIZE ? pc -= MEM_SIZE : pc;
opcodes/op_and.c:		reg->cycle = 0;
opcodes/op_fork.c:	ret->n = reg->n;
opcodes/op_fork.c:	ret->pc = reg->pc;
opcodes/op_fork.c:	ret->cycle = reg->cycle;
opcodes/op_fork.c:	ret->carry = reg->carry;
opcodes/op_fork.c:	ret->live_counter = reg->live_counter;;
opcodes/op_fork.c:	ft_memcpy(ret->r, reg->r, sizeof(int) * REG_NUMBER);
opcodes/op_fork.c:	while (reg && reg->prev)
opcodes/op_fork.c:		reg = reg->prev;
opcodes/op_fork.c:	if (reg->next)
opcodes/op_fork.c:		reg->prev = ret;
opcodes/op_fork.c:	if (++reg->cycle == 800)
opcodes/op_fork.c:		reg->cycle = 0;
opcodes/op_fork.c:		pc = find_hexa(d->map, reg->pc + 1, 2);
opcodes/op_fork.c:		reg->next = fork_reg(reg);
opcodes/op_fork.c:		jump_to_next(d, reg->next, pc % IDX_MOD, true);
opcodes/op_ld.c:	if (++reg->cycle == 5)
opcodes/op_ld.c:		(pc = reg->pc + 1) >= MEM_SIZE ? pc -= MEM_SIZE : pc;
opcodes/op_ld.c:			param = find_hexa(d->map, reg->pc + (param % IDX_MOD), 4);
opcodes/op_ld.c:		r = d->map[reg->pc];
opcodes/op_ld.c:		reg->r[r - 1] = param;
opcodes/op_ld.c:		reg->carry = !param ? 1 : 0;
opcodes/op_ld.c:		reg->cycle = 0;
opcodes/op_ldi.c:	if (++reg->cycle == 25)
opcodes/op_ldi.c:		reg->cycle = 0;
opcodes/op_ldi.c:		(pc = reg->pc + 1) >= MEM_SIZE ? pc -= MEM_SIZE : pc;
opcodes/op_ldi.c:				r[i] = reg->r[r[i] - 1];
opcodes/op_ldi.c:				r[i] = find_hexa(d->map, reg->pc + (r[i] % IDX_MOD), 4);
opcodes/op_ldi.c:		tmp = reg->pc - ((r[0] + r[1]) % IDX_MOD);
opcodes/op_ldi.c:			reg->r[r[2] - 1] = find_hexa(d->map, tmp, 4);
opcodes/op_ldi.c:		jump_to_next(d, reg, pc - reg->pc, false);
opcodes/op_ldi.c:		//printw("reg->r[%d] =\t%x\n", r[2] - 1, reg->r[r[2] - 1]);
opcodes/op_ldi.c:		//printw("\t\t%d\n", reg->r[r[2] - 1]);
opcodes/op_lfork.c:	if (++reg->cycle == 1000)
opcodes/op_lfork.c:		reg->cycle = 0;
opcodes/op_lfork.c:		pc = find_hexa(d->map, reg->pc + 1, 2);
opcodes/op_lfork.c:		reg->next = fork_reg(reg);
opcodes/op_lfork.c:		jump_to_next(d, reg->next, pc, true);
opcodes/op_live.c:	attron(COLOR_PAIR(d->colors[reg->pc] - 5));
opcodes/op_live.c:	attroff(COLOR_PAIR(d->colors[reg->pc] - 5));
opcodes/op_live.c:	printw(": IM ALIIIVE\n", reg->n);
opcodes/op_live.c:	if (++reg->cycle == 10)
opcodes/op_live.c:		reg->cycle = 0;
opcodes/op_live.c:		reg->live_counter++;
opcodes/op_live.c:		d->last_live_call = reg->n;
opcodes/op_lld.c:	if (++reg->cycle == 5)
opcodes/op_lld.c:		(pc = reg->pc + 1) >= MEM_SIZE ? pc -= MEM_SIZE : pc;
opcodes/op_lld.c:			param = find_hexa(d->map, reg->pc + param, 4);
opcodes/op_lld.c:		r = d->map[reg->pc];
opcodes/op_lld.c:		reg->r[r - 1] = param;
opcodes/op_lld.c:		reg->carry = !param ? 1 : 0;
opcodes/op_lld.c:		reg->cycle = 0;
opcodes/op_lldi.c:	if (++reg->cycle == 25)
opcodes/op_lldi.c:		reg->cycle = 0;
opcodes/op_lldi.c:		(pc = reg->pc + 1) >= MEM_SIZE ? pc -= MEM_SIZE : pc;
opcodes/op_lldi.c:				r[i] = reg->r[r[i] - 1];
opcodes/op_lldi.c:		tmp = reg->pc - (r[0] + r[1]);
opcodes/op_lldi.c:			reg->r[r[2] - 1] = find_hexa(d->map, tmp, 4);
opcodes/op_lldi.c:		jump_to_next(d, reg, pc - reg->pc, false);
opcodes/op_or.c:	reg->r[r[2]] = r[0] | r[1];
opcodes/op_or.c:	reg->carry = !reg->r[r[2]] ? 1 : 0;
opcodes/op_or.c:	if (++reg->cycle == 7)
opcodes/op_or.c:		(pc = reg->pc + 1) >= MEM_SIZE ? pc -= MEM_SIZE : pc;
opcodes/op_or.c:		reg->cycle = 0;
opcodes/op_st.c:	if (++reg->cycle == 5)
opcodes/op_st.c:		(pc = reg->pc + 1) >= MEM_SIZE ? pc -= MEM_SIZE : pc;
opcodes/op_st.c:				put_hexa(d, reg->n, reg->pc + param, reg->r[r - 1]);
opcodes/op_st.c:				printw("reg->pc =\t%d\n", reg->pc);
opcodes/op_st.c:				printw("reg->pc =\t%x\n", reg->pc);
opcodes/op_st.c:				printw("reg->r[%d] =\t%d\n", r - 1, param);
opcodes/op_st.c:				printw("reg->r[%d] =\t%x\n", r - 1, param);
opcodes/op_st.c:				reg->r[param - 1] = reg->r[r - 1];
opcodes/op_st.c:		reg->cycle = 0;
opcodes/op_sti.c:	if (++reg->cycle == 25)
opcodes/op_sti.c:		reg->cycle = 0;
opcodes/op_sti.c:		(pc = reg->pc + 1) >= MEM_SIZE ? pc -= MEM_SIZE : pc;
opcodes/op_sti.c:				r[i] = reg->r[r[i] - 1];
opcodes/op_sti.c:				r[i] = find_hexa(d->map, reg->pc + (r[i] % IDX_MOD), 4);
opcodes/op_sti.c:		tmp = reg->pc + ((r[1] + r[2]) % IDX_MOD);
opcodes/op_sti.c:		put_hexa(d, reg->n, tmp, r[0]);
opcodes/op_sti.c:		jump_to_next(d, reg, pc - reg->pc, false);
opcodes/op_sub.c:	if (++reg->cycle == 10)
opcodes/op_sub.c:		(pc = reg->pc + 2) >= MEM_SIZE ? pc -= MEM_SIZE : pc;
opcodes/op_sub.c:			reg->r[r[2]] = reg->r[r[0]] - reg->r[r[1]];
opcodes/op_sub.c:			reg->carry = !reg->r[r[2]] ? 1 : 0;
opcodes/op_sub.c:		reg->cycle = 0;
opcodes/op_sub.c:		//printw("r%d = %d\n", r[0], reg->r[r[0]]);
opcodes/op_sub.c:		//printw("r%d = %d\n", r[1], reg->r[r[1]]);
opcodes/op_sub.c:		//printw("r%d = %d\n", r[2], reg->r[r[2]]);
opcodes/op_xor.c:	reg->r[r[2]] = r[0] ^ r[1];
opcodes/op_xor.c:	reg->carry = !reg->r[r[2]] ? 1 : 0;
opcodes/op_xor.c:	if (++reg->cycle == 8)
opcodes/op_xor.c:		(pc = reg->pc + 1) >= MEM_SIZE ? pc -= MEM_SIZE : pc;
opcodes/op_xor.c:		reg->cycle = 0;
opcodes/op_zjmp.c:	if (++reg->cycle == 20)
opcodes/op_zjmp.c:		if (reg->carry == 1)
opcodes/op_zjmp.c:			if ((pc = find_hexa(d->map, reg->pc + 1, 2)) == -1)
opcodes/op_zjmp.c:				pc = reg->pc + 3;
opcodes/op_zjmp.c:			jump_to_next(d, reg, MEM_SIZE - reg->pc + pc, false);
opcodes/op_zjmp.c:			reg->cycle = 0;
utils.c:	if (!fork && !(is_anybody_here(d, reg->pc)))
utils.c:		d->colors[reg->pc] -= 5;
utils.c:	reg->pc += o;
utils.c:	while (reg->pc >= MEM_SIZE || reg->pc < 0)
utils.c:		if (reg->pc >= MEM_SIZE)
utils.c:			reg->pc -= MEM_SIZE;
utils.c:		else if (reg->pc < 0)
utils.c:			reg->pc += MEM_SIZE;
utils.c:	if (!(is_anybody_here(d, reg->pc)))
utils.c:		d->colors[reg->pc] += 5;
utils.c:	//d->colors[reg->pc] += 5 >= 10 ? 0 : 5;
